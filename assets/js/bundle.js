/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("// import * as THREE from \"three\";\n// import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n// import vertexShader from \"./shaders/vertexShader.glsl\";\n// import fragmentShader from \"./shaders/fragmentShader.glsl\";\n\n// if (document.querySelector(\"#webgl1\") !== null) {\n//   // #canvas1用の初期化コード\n\n//   /**\n//    * Sizes\n//    */\n//   const sizes = {\n//     width: window.innerWidth,\n//     height: window.innerHeight,\n//   };\n\n//   // Canvas\n//   const canvas = document.querySelector(\"#webgl\");\n\n//   // Scene\n//   const scene = new THREE.Scene();\n\n//   /**\n//    * Textures\n//    */\n//   const textureLoader = new THREE.TextureLoader();\n\n//   // Geometry\n//   const geometry = new THREE.PlaneGeometry(1, 1, 32, 32);\n\n//   // Material\n//   const material = new THREE.ShaderMaterial({\n//     vertexShader,\n//     fragmentShader,\n//   });\n\n//   // Mesh\n//   const mesh = new THREE.Mesh(geometry, material);\n//   scene.add(mesh);\n\n//   // Camera\n//   const camera = new THREE.PerspectiveCamera(\n//     75,\n//     sizes.width / sizes.height,\n//     0.1,\n//     100\n//   );\n//   camera.position.set(0.25, -0.25, 1);\n//   scene.add(camera);\n\n//   // Controls\n//   const controls = new OrbitControls(camera, canvas);\n//   controls.enableDamping = true;\n\n//   /**\n//    * Renderer\n//    */\n//   const renderer = new THREE.WebGLRenderer({\n//     canvas: canvas,\n//   });\n//   renderer.setSize(sizes.width, sizes.height);\n//   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n\n//   window.addEventListener(\"resize\", () => {\n//     sizes.width = window.innerWidth;\n//     sizes.height = window.innerHeight;\n\n//     camera.aspect = sizes.width / sizes.height;\n//     camera.updateProjectionMatrix();\n\n//     renderer.setSize(sizes.width, sizes.height);\n//     renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n//   });\n\n//   /**\n//    * Animate\n//    */\n//   const clock = new THREE.Clock();\n\n//   const animate = () => {\n//     //時間取得\n//     const elapsedTime = clock.getElapsedTime();\n\n//     controls.update();\n\n//     renderer.render(scene, camera);\n\n//     window.requestAnimationFrame(animate);\n//   };\n\n//   animate();\n// }\n\n// else  (document.querySelector('#canvas2') !== null) {\n//   // #canvas2用の初期化コード\n// }\n\n(function () {\n  let unit = 100,\n    canvas,\n    info = {\n      seconds: 0,\n      t: 0\n    },\n    // 初期値を設定\n    colors;\n  function init() {\n    colors = [\"#ffffff\", \"#7BADEF\"];\n    canvas = document.querySelector(\"#waveCanvas\");\n    if (!canvas) return; // canvasがなければ初期化を中断\n\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = 160;\n    canvas.contextCache = canvas.getContext(\"2d\");\n    startAnimation();\n  }\n  function startAnimation() {\n    if (info.animationFrameId) {\n      cancelAnimationFrame(info.animationFrameId); // 前のアニメーションフレームをキャンセル\n    }\n    update();\n  }\n  function update() {\n    draw();\n\n    // 波の速度を調整\n    info.seconds += 0.007; // ここで波の速度を調整（値を小さくすると速度が遅くなる）\n    info.t = -info.seconds * Math.PI;\n    info.animationFrameId = requestAnimationFrame(update);\n  }\n  function draw() {\n    let context = canvas.contextCache;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.globalAlpha = 0.5;\n    drawWave(colors[0], 3, 0);\n    context.globalAlpha = 1;\n    drawWave(colors[1], 2, 150);\n  }\n  function drawWave(color, zoom, delay) {\n    let context = canvas.contextCache;\n    context.fillStyle = color;\n    context.beginPath();\n    drawSine(info.t / 0.5, zoom, delay);\n    context.lineTo(canvas.width + 10, canvas.height);\n    context.lineTo(0, canvas.height);\n    context.closePath();\n    context.fill();\n  }\n  function drawSine(t, zoom, delay) {\n    let xAxis = Math.floor(canvas.height / 2);\n    let context = canvas.contextCache;\n    for (let i = 0; i <= canvas.width + 10; i += 10) {\n      let x = t + (-0 + i) / unit / zoom;\n      let y = Math.sin(x - delay) / 3;\n\n      // 右側を高く、左側をより低くするための調整を強化\n      let positionFactor = i / canvas.width;\n      // 左側をさらに低くするために、影響を強化する\n      let heightAdjustmentFactor = Math.pow(positionFactor, 1); // 右側が高くなる効果を強化\n      let yOffsetAdjustment = Math.pow(1 - positionFactor, 1) * canvas.height / 2; // 左側をより低くする\n\n      context.lineTo(i, unit * y * heightAdjustmentFactor + xAxis - yOffsetAdjustment);\n    }\n  }\n  window.addEventListener(\"resize\", init);\n  init();\n})();\n(function () {\n  let unit = 100,\n    canvas,\n    info = {\n      seconds: 0,\n      t: 0\n    },\n    // 初期値を設定\n    colors;\n  function init() {\n    colors = [\"#FFFFFF80\", \"#FAF7D5\"]; // 色を変更します（例: \"#ADD8E6\"はlight blue、\"#6495ED\"はcornflower blue）\n\n    canvas = document.getElementById(\"waveCanvas2\"); // IDを\"waveCanvas2\"に変更\n    if (!canvas) return; // canvasがなければ初期化を中断\n\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = 160; // 高さを設定\n    canvas.contextCache = canvas.getContext(\"2d\"); // コンテキストをキャッシュ\n\n    startAnimation();\n  }\n  function startAnimation() {\n    if (info.animationFrameId) {\n      cancelAnimationFrame(info.animationFrameId); // 前のアニメーションフレームをキャンセル\n    }\n    update();\n  }\n  function update() {\n    draw();\n\n    // 波の速度を調整\n    info.seconds += 0.007; // ここで波の速度を調整（値を小さくすると速度が遅くなる）\n    info.t = -info.seconds * Math.PI;\n    info.animationFrameId = requestAnimationFrame(update);\n  }\n  function draw() {\n    let context = canvas.contextCache;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.globalAlpha = 0.5;\n    drawWave(colors[0], 3, 0); // 第1の波を描画\n\n    context.globalAlpha = 1;\n    drawWave(colors[1], 2, 150); // 第2の波を描画\n  }\n  function drawWave(color, zoom, delay) {\n    let context = canvas.contextCache;\n    context.fillStyle = color;\n    context.beginPath();\n    drawSine(info.t / 0.5, zoom, delay);\n    context.lineTo(canvas.width + 10, canvas.height);\n    context.lineTo(0, canvas.height);\n    context.closePath();\n    context.fill();\n  }\n  function drawSine(t, zoom, delay) {\n    let xAxis = Math.floor(canvas.height / 2);\n    let context = canvas.contextCache;\n    for (let i = 0; i <= canvas.width + 10; i += 10) {\n      let x = t + (-0 + i) / unit / zoom;\n      let y = Math.sin(x - delay) / 3;\n\n      // 右側を高く、左側をより低くするための調整を強化\n      let positionFactor = i / canvas.width;\n      // 左側をさらに低くするために、影響を強化する\n      let heightAdjustmentFactor = Math.pow(positionFactor, 1); // 右側が高くなる効果を強化\n      let yOffsetAdjustment = Math.pow(1 - positionFactor, 1) * canvas.height / 2; // 左側をより低くする\n\n      context.lineTo(i, unit * y * heightAdjustmentFactor + xAxis - yOffsetAdjustment);\n    }\n  }\n  window.addEventListener(\"resize\", init);\n  init();\n})();\n(function () {\n  let unit = 100,\n    canvas,\n    info = {\n      seconds: 0,\n      t: 0\n    },\n    // 初期値を設定\n    colors;\n  function init() {\n    colors = [\"#FFFFFF80\", \"#D2E6FF\"];\n    canvas = document.getElementById(\"waveCanvas3\"); // IDを\"waveCanvas3\"に変更\n    if (!canvas) return; // canvasがなければ初期化を中断\n\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = 160;\n    canvas.contextCache = canvas.getContext(\"2d\");\n    startAnimation();\n  }\n  function startAnimation() {\n    if (info.animationFrameId) {\n      cancelAnimationFrame(info.animationFrameId); // 前のアニメーションフレームをキャンセル\n    }\n    update();\n  }\n  function update() {\n    draw();\n\n    // 波の速度を調整\n    info.seconds += 0.007; // ここで波の速度を調整（値を小さくすると速度が遅くなる）\n    info.t = -info.seconds * Math.PI;\n    info.animationFrameId = requestAnimationFrame(update);\n  }\n  function draw() {\n    let context = canvas.contextCache;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.globalAlpha = 0.5;\n    drawWave(colors[0], 3, 0);\n    context.globalAlpha = 1;\n    drawWave(colors[1], 2, 150);\n  }\n  function drawWave(color, zoom, delay) {\n    let context = canvas.contextCache;\n    context.fillStyle = color;\n    context.beginPath();\n    drawSine(info.t / 0.5, zoom, delay);\n    context.lineTo(canvas.width + 10, canvas.height);\n    context.lineTo(0, canvas.height);\n    context.closePath();\n    context.fill();\n  }\n  function drawSine(t, zoom, delay) {\n    let xAxis = Math.floor(canvas.height / 2);\n    let context = canvas.contextCache;\n    for (let i = 0; i <= canvas.width + 10; i += 10) {\n      let x = t + (-0 + i) / unit / zoom;\n      let y = Math.sin(x - delay) / 3;\n\n      // 右側を高く、左側をより低くするための調整を強化\n      let positionFactor = i / canvas.width;\n      // 左側をさらに低くするために、影響を強化する\n      let heightAdjustmentFactor = Math.pow(positionFactor, 1); // 右側が高くなる効果を強化\n      let yOffsetAdjustment = Math.pow(1 - positionFactor, 1) * canvas.height / 2; // 左側をより低くする\n\n      context.lineTo(i, unit * y * heightAdjustmentFactor + xAxis - yOffsetAdjustment);\n    }\n  }\n  window.addEventListener(\"resize\", init);\n  init();\n})();\n\n// // videの場合\n// // モーダルを取得\n// let modal = document.querySelector(\".bl_videoModal\");\n\n// // モーダルを開くボタンを取得\n// let btn = document.querySelector(\".bl_videoBlock_link\");\n\n// // モーダルを閉じる<span>要素を取得\n// let span = document.querySelector(\".bl_videoModal_closeBtn\");\n\n// // ビデオ要素を取得\n// let video = modal.querySelector(\"video\");\n\n// // ボタンをクリックするとモーダルを表示し、ビデオを再生\n// btn.addEventListener(\"click\", function (event) {\n//   event.preventDefault(); // デフォルトの動作（リンクの遷移など）をキャンセル\n//   modal.style.display = \"block\";\n//   setTimeout(() => {\n//     modal.classList.add(\"show\"); // 少し遅らせて.showクラスを追加\n//     video.play(); // ビデオを再生\n//   }, 10); // DOMが更新されるのを待つために微小な遅延を設ける\n// });\n\n// // <span> (x) またはモーダルの外側をクリックするとモーダルを閉じ、ビデオを停止\n// const closeModal = () => {\n//   modal.classList.remove('show'); // .showクラスを削除してフェードアウト\n//   setTimeout(() => {\n//     modal.style.display = \"none\"; // 完全に非表示にする\n//     video.pause(); // ビデオの再生を停止\n//     video.currentTime = 0; // ビデオを最初から再開するために時間をリセット\n//   }, 500); // アニメーションの時間に合わせて遅延を設ける\n// };\n\n// span.onclick = closeModal;\n\n// window.onclick = function(event) {\n//   if (event.target == modal) {\n//     closeModal();\n//   }\n// };\n\n// youtubeの場合\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  // bodyタグにfrontPageのIDが存在するかチェック\n  if (document.body.id === \"frontPage\") {\n    // DOM要素を取得\n    let modal = document.querySelector(\".bl_videoModal\");\n    let btn = document.querySelector(\".bl_videoBlock_link\");\n    let span = document.querySelector(\".bl_videoModal_closeBtn\");\n    let iframe = document.querySelector(\".bl_videoModal_video\");\n    let body = document.body; // スクロール禁止を適用するためのbody要素\n\n    // YouTubeの動画IDと基本URL\n    let videoID = \"UTnE0qQ41eE\"; // ここに動画IDを設定\n    let baseURL = `https://www.youtube.com/embed/${videoID}?`;\n\n    // モーダルを開くボタンをクリックするとモーダルを表示\n    btn.addEventListener(\"click\", function (event) {\n      event.preventDefault();\n      modal.style.display = \"block\";\n      body.classList.add(\"js_bodyNoScroll\"); // スクロール禁止クラスを追加\n      setTimeout(() => {\n        modal.classList.add(\"is_show\");\n        // 自動再生するURLを設定（ミュートなし）\n        iframe.src = `${baseURL}autoplay=1`; // ミュートを解除\n      }, 10);\n    });\n\n    // モーダルを閉じる関数\n    const closeModal = () => {\n      modal.classList.remove(\"is_show\");\n      setTimeout(() => {\n        modal.style.display = \"none\";\n        body.classList.remove(\"js_bodyNoScroll\"); // スクロール禁止クラスを削除\n        // 再生を停止し、iframeのsrcをリセット\n        iframe.src = \"\";\n      }, 500);\n    };\n\n    // クリックイベントを追加\n    span.onclick = closeModal;\n    window.onclick = function (event) {\n      if (event.target == modal) {\n        closeModal();\n      }\n    };\n  }\n});\n\n// グローバルナビ\n// document.addEventListener(\"DOMContentLoaded\", function () {\n//   // 全てのハンバーガーメニューボタンを取得\n//   const hamburgerButtons = document.querySelectorAll(\".el_hamburger\");\n\n//   // 各ハンバーガーメニューボタンにイベントリスナーを設定\n//   hamburgerButtons.forEach(function (button) {\n//     button.addEventListener(\"click\", function () {\n//       // aria-expanded属性の切り替え\n//       const expanded = this.getAttribute(\"aria-expanded\") === \"true\";\n//       this.setAttribute(\"aria-expanded\", !expanded);\n\n//       // クリックされたハンバーガーメニューに関連付けられたグローバルナビを取得\n//       const selector = this.getAttribute(\"aria-controls\");\n//       const globalNavi = document.getElementById(selector);\n\n//       console.log(\"Selector:\", selector); // ここでセレクターをログ出力\n//       console.log(\"Global Navi Element:\", globalNavi); // ここで取得された要素をログ出力\n\n//       // グローバルナビが存在する場合、.activeクラスをトグル\n//       if (globalNavi) {\n//         globalNavi.classList.toggle(\"active\");\n//       }\n\n//       // ハンバーガーメニュー自身にも.activeクラスをトグル\n//       this.classList.toggle(\"active\");\n//     });\n//   });\n// });\n\n// document.addEventListener(\"DOMContentLoaded\", function () {\n//   // ナビゲーションリンクにイベントリスナーを追加\n//   document.querySelectorAll(\".bl_globalNavi_link a\").forEach(function (link) {\n//     link.addEventListener(\"click\", function () {\n//       // ドロワーメニューの取得\n//       const drawer = document.getElementById(\"drawer\");\n//       if (drawer.classList.contains(\"active\")) {\n//         drawer.classList.remove(\"active\");\n//       }\n\n//       // ハンバーガーメニューボタンのaria-expanded属性と.activeクラスを更新\n//       const hamburgerButton = document.querySelector(\".el_hamburger\");\n//       if (hamburgerButton.getAttribute(\"aria-expanded\") === \"true\") {\n//         hamburgerButton.setAttribute(\"aria-expanded\", \"false\");\n//         hamburgerButton.classList.remove(\"active\");\n//       }\n//     });\n//   });\n\n//   // ハンバーガーメニューボタンにイベントリスナーを設定\n//   const hamburgerButton = document.querySelector(\".el_hamburger\");\n//   hamburgerButton.addEventListener(\"click\", function () {\n//     const expanded = this.getAttribute(\"aria-expanded\") === \"true\";\n//     this.setAttribute(\"aria-expanded\", !expanded);\n//     this.classList.toggle(\"active\");\n\n//     // 関連するドロワーメニューの取得\n//     const drawer = document.getElementById(this.getAttribute(\"aria-controls\"));\n//     drawer.classList.toggle(\"active\");\n//   });\n// });\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  // ハンバーガーメニューボタンにイベントリスナーを設定\n  document.querySelectorAll(\".el_hamburger\").forEach(function (button) {\n    button.addEventListener(\"click\", function () {\n      const expanded = this.getAttribute(\"aria-expanded\") === \"true\";\n      this.setAttribute(\"aria-expanded\", !expanded);\n      this.classList.toggle(\"active\");\n\n      // 関連するドロワーメニューの取得とトグル\n      const drawer = document.getElementById(this.getAttribute(\"aria-controls\"));\n      if (drawer) {\n        drawer.classList.toggle(\"active\");\n      }\n    });\n  });\n\n  // 全てのナビゲーションリンクにイベントリスナーを追加\n  document.querySelectorAll(\".bl_globalNavi_link a\").forEach(function (link) {\n    link.addEventListener(\"click\", function () {\n      // 全てのドロワーメニューとハンバーガーメニューボタンを処理\n      document.querySelectorAll(\".el_hamburger\").forEach(function (button) {\n        const controls = button.getAttribute(\"aria-controls\");\n        const drawer = document.getElementById(controls);\n        if (drawer && drawer.classList.contains(\"active\")) {\n          drawer.classList.remove(\"active\");\n          button.setAttribute(\"aria-expanded\", \"false\");\n          button.classList.remove(\"active\");\n        }\n      });\n    });\n  });\n});\n\n// 波の非表示\n// ここでは、ボタンのクリックにより波形SVGの表示状態を制御します。\ndocument.querySelector(\".el_hamburger\").addEventListener(\"click\", function () {\n  // .bl_globalNavi_wave1 と .bl_globalNavi_wave2 を取得\n  const wave1 = document.querySelector(\".bl_globalNavi_wave1\");\n  const wave2 = document.querySelector(\".bl_globalNavi_wave2\");\n\n  // 各要素にactiveクラスをトグル\n  wave1.classList.toggle(\"active\");\n  wave2.classList.toggle(\"active\");\n});\n\n// pop\n// ホバー対象の要素を取得\ndocument.addEventListener(\"DOMContentLoaded\", event => {\n  // ホバー対象の要素をすべて取得\n  const appleLinkWrappers = document.querySelectorAll(\".el_appleLink_wrapper\");\n  appleLinkWrappers.forEach(wrapper => {\n    const appLinkPop = wrapper.querySelector(\".el_appLink_pop\"); // 各wrapperに対する.pop要素を取得\n\n    if (appLinkPop) {\n      // ホバー時のイベントリスナーを追加\n      wrapper.addEventListener(\"mouseenter\", function () {\n        // ホバー時に.pop要素に.activeクラスを追加\n        appLinkPop.classList.add(\"active\");\n      });\n\n      // ホバーが解除された時のイベントリスナーを追加\n      wrapper.addEventListener(\"mouseleave\", function () {\n        // ホバー解除時に.pop要素から.activeクラスを削除\n        appLinkPop.classList.remove(\"active\");\n      });\n    }\n  });\n});\n\n// ドラッグ操作の追加\nlet isDown = false; // マウスがクリックされているか追跡\nlet startY; // ドラッグ開始のY座標\nlet scrollTop; // ドラッグ開始時のスクロール位置\n\nconst end = () => {\n  isDown = false;\n  document.body.style.cursor = \"\"; // マウスカーソルのスタイルを元に戻す\n};\ndocument.body.addEventListener(\"mousedown\", e => {\n  isDown = true;\n  startY = e.pageY - document.body.offsetTop;\n  scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n  document.body.style.cursor = \"grabbing\"; // ドラッグ中のマウスカーソルのスタイル\n});\ndocument.body.addEventListener(\"mouseleave\", end);\ndocument.body.addEventListener(\"mouseup\", end);\ndocument.body.addEventListener(\"mousemove\", e => {\n  if (!isDown) return; // マウスがクリックされていなければ何もしない\n  e.preventDefault(); // デフォルトのイベントをキャンセル\n  const y = e.pageY - document.body.offsetTop;\n  const walk = (y - startY) * 1; // ドラッグの距離 * スクロール速度\n  window.scrollTo(0, scrollTop - walk);\n});\n\n// anime js\nif (document.querySelector(\".bl_bubble\")) {\n  anime({\n    targets: \".bl_bubble\",\n    keyframes: [{\n      scaleX: 1.05,\n      scaleY: 0.95,\n      translateX: -10,\n      translateY: -10,\n      duration: 2000\n    }, {\n      scaleX: 0.95,\n      scaleY: 1.05,\n      translateX: 10,\n      translateY: 10,\n      duration: 2000\n    }, {\n      scaleX: 1.1,\n      scaleY: 0.9,\n      translateX: -20,\n      translateY: -20,\n      duration: 2000\n    }, {\n      scaleX: 0.9,\n      scaleY: 1.1,\n      translateX: 20,\n      translateY: 20,\n      duration: 2000\n    }, {\n      scaleX: 1,\n      scaleY: 1,\n      translateX: 0,\n      translateY: 0,\n      duration: 2000\n    },\n    // 追加する不規則な動き\n    {\n      scaleX: 1.03,\n      scaleY: 0.97,\n      translateX: 15,\n      translateY: -15,\n      duration: 2000\n    }, {\n      scaleX: 0.97,\n      scaleY: 1.03,\n      translateX: -15,\n      translateY: 15,\n      duration: 2000\n    }, {\n      scaleX: 1,\n      scaleY: 1,\n      translateX: 0,\n      translateY: 0,\n      duration: 2000\n    }],\n    loop: true,\n    easing: \"easeInOutSine\",\n    duration: 10000\n  });\n}\n\n// app固定用\nfunction adjustElementPosition() {\n  const element = document.querySelector(\".your-fixed-element\");\n  if (element) {\n    element.style.bottom = \"0\";\n    element.style.left = \"0\";\n  }\n}\n\n// ページ読み込み時と画面サイズ変更時に位置を調整\nwindow.addEventListener(\"load\", adjustElementPosition);\nwindow.addEventListener(\"resize\", adjustElementPosition);\n\n/**\r\n *\r\n *\r\n *\r\n *\r\n *\r\n * fvアニメーション\r\n */\n/**\r\n * tiltSlider.js v1.0.0\r\n * http://www.codrops.com\r\n *\r\n * Licensed under the MIT license.\r\n * http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Copyright 2014, Codrops\r\n * http://www.codrops.com\r\n */\n(function (window) {\n  \"use strict\";\n\n  // ページにid=\"fv\"が存在するかどうかをチェック\n  var fvElement = document.getElementById(\"fv\");\n  if (!fvElement) {\n    // id=\"fv\"がない場合は、これ以降のコードを実行しない\n    return;\n  }\n  Modernizr.addTest(\"csstransformspreserve3d\", function () {\n    var prop = Modernizr.prefixed(\"transformStyle\");\n    var val = \"preserve-3d\";\n    var computedStyle;\n    if (!prop) return false;\n    prop = prop.replace(/([A-Z])/g, function (str, m1) {\n      return \"-\" + m1.toLowerCase();\n    }).replace(/^ms-/, \"-ms-\");\n    Modernizr.testStyles(\"#modernizr{\" + prop + \":\" + val + \";}\", function (el, rule) {\n      computedStyle = window.getComputedStyle ? getComputedStyle(el, null).getPropertyValue(prop) : \"\";\n    });\n    return computedStyle === val;\n  });\n  var support = {\n      animations: Modernizr.cssanimations,\n      preserve3d: Modernizr.csstransformspreserve3d,\n      transforms3d: Modernizr.csstransforms3d\n    },\n    isSupported = support.animations && support.preserve3d && support.transforms3d,\n    animEndEventNames = {\n      WebkitAnimation: \"webkitAnimationEnd\",\n      OAnimation: \"oAnimationEnd\",\n      msAnimation: \"MSAnimationEnd\",\n      animation: \"animationend\"\n    },\n    // animation end event name\n    animEndEventName = animEndEventNames[Modernizr.prefixed(\"animation\")];\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n    return a;\n  }\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    var el = document.querySelector(\"#slideshow\");\n    if (el) {\n      var tiltSlider = new TiltSlider(el); // ここで TiltSlider のインスタンスを作成\n      tiltSlider._initEvents(); // インスタンスに対して initEvents メソッドを直接呼び出す\n    } else {\n      console.log(\"Slideshow element not found\");\n    }\n  });\n  function TiltSlider(el, options) {\n    this.el = el;\n    // available effects for the animations (animation class names) - when a item comes in / out\n    this.animEffectsOut = [\"slideRightOut\"];\n    this.animEffectsIn = [\"slideRightIn\"];\n\n    // the items olの子のliを取得\n    this.items = this.el.querySelector(\"ol.slides\").children;\n\n    // total items\n    this.itemsCount = this.items.length;\n    if (!this.itemsCount) return;\n\n    // index of the current item\n    this.current = 0;\n    this.options = extend({}, this.options);\n    extend(this.options, options);\n    this._init();\n  }\n  TiltSlider.prototype.options = {};\n  TiltSlider.prototype._init = function () {\n    // this._addNavigation();\n    this._initEvents();\n    this._initScrollEvents(); // スクロールイベントの初期化\n    this._initDragEvents(); // ドラッグイベントの初期化\n  };\n  TiltSlider.prototype._initScrollEvents = function () {\n    var self = this,\n      lastTime = 0;\n    window.addEventListener(\"wheel\", function (e) {\n      var delta = e.deltaY,\n        currentTime = new Date().getTime();\n\n      // 短時間に複数回のスクロールイベントが発生するのを防ぐ\n      if (currentTime - lastTime < 1200) {\n        return;\n      }\n      if (delta > 0) {\n        self._showItem(self.current + 1); // 下にスクロールすると次のスライドへ\n      } else {\n        self._showItem(self.current - 1); // 上にスクロールすると前のスライドへ\n      }\n      lastTime = currentTime;\n    });\n  };\n  TiltSlider.prototype._initDragEvents = function () {\n    var self = this,\n      startX,\n      endX;\n    this.el.addEventListener('mousedown', function (e) {\n      startX = e.pageX;\n      self.isDragging = true;\n    });\n    window.addEventListener('mousemove', function (e) {\n      if (!self.isDragging) return;\n      endX = e.pageX;\n    });\n    window.addEventListener('mouseup', function (e) {\n      if (!self.isDragging) return;\n      self.isDragging = false;\n      var threshold = 100; // ドラッグの閾値\n      if (Math.abs(startX - endX) > threshold) {\n        var direction = startX > endX ? 1 : -1;\n        // スライドのインデックスを更新して循環させる\n        var newPos = (self.current + direction + self.itemsCount) % self.itemsCount;\n        self._showItem(newPos);\n      }\n    });\n  };\n\n  // add the navigation to the DOM　ナビ\n  TiltSlider.prototype._addNavigation = function () {\n    // // add nav \"dots\"\n    // this.nav = document.createElement(\"nav\");\n    // var inner = \"\";\n    // for (var i = 0; i < this.itemsCount; ++i) {\n    //   inner += i === 0 ? '<span class=\"current\"></span>' : \"<span></span>\";\n    // }\n    // this.nav.innerHTML = inner;\n    // this.el.appendChild(this.nav);\n    // this.navDots = [].slice.call(this.nav.children);\n  };\n  TiltSlider.prototype._initEvents = function () {\n    // var self = this;\n    // this.navDots.forEach(function (dot, idx) {\n    //     dot.addEventListener(\"click\", function () {\n    //         if (self.isAnimating) return; // アニメーション中は処理を行わない\n\n    //         // idxが現在のスライドインデックスと同じで、それが最後のスライドの場合、最初のスライドへ戻る\n    //         if (idx === self.current && idx === self.itemsCount - 1) {\n    //             self._showItem(0); // 最初のスライドへ\n    //         } else {\n    //             self._showItem(idx); // それ以外の場合はクリックされたスライドへ\n    //         }\n    //     });\n    // });\n  };\n  TiltSlider.prototype._showItem = function (pos) {\n    if (this.isAnimating || pos < 0 || pos >= this.itemsCount) return false;\n    this.isAnimating = true;\n    var currentItem = this.items[this.current],\n      // 現在のアイテム\n      nextItem = this.items[pos]; // 次に表示するアイテム\n\n    if (!currentItem || !nextItem) {\n      console.error('Invalid items: currentItem or nextItem is undefined');\n      this.isAnimating = false;\n      return;\n    }\n\n    // スライドの範囲を超えていないかチェックし、必要に応じてリセット\n    if (pos >= this.itemsCount) {\n      pos = 0;\n    }\n    var self = this,\n      currentItem = this.items[this.current],\n      // 現在のアイテム\n      nextItem = this.items[pos]; // 次に表示するアイテム\n\n    var outEffect = \"slideRightOut\",\n      inEffect = \"slideRightIn\";\n    currentItem.setAttribute(\"data-effect-out\", outEffect);\n    nextItem.setAttribute(\"data-effect-in\", inEffect);\n    var onEndAnimationCurrentItem = function () {\n      currentItem.removeEventListener(animEndEventName, onEndAnimationCurrentItem);\n      classie.removeClass(currentItem, \"hide\");\n      classie.addClass(nextItem, \"show\");\n    };\n    var onEndAnimationNextItem = function () {\n      nextItem.removeEventListener(animEndEventName, onEndAnimationNextItem);\n      classie.removeClass(nextItem, \"show\");\n      classie.addClass(nextItem, \"current\");\n      self.isAnimating = false;\n    };\n    currentItem.addEventListener(animEndEventName, onEndAnimationCurrentItem);\n    nextItem.addEventListener(animEndEventName, onEndAnimationNextItem);\n    this.current = pos; // Update the current position\n    classie.addClass(currentItem, \"hide\"); // Start the 'out' animation\n  };\n\n  // add to global namespace\n  window.TiltSlider = TiltSlider;\n})(window);\n\n/**\r\n * Gsap\r\n */\n\nif (document.body.id === \"frontPage\") {\n  gsap.registerPlugin(ScrollTrigger);\n  console.log('p_top');\n  gsap.utils.toArray('.scroll-fade-in').forEach(function (element) {\n    gsap.from(element, {\n      duration: 1.5,\n      y: 50,\n      opacity: 0,\n      ease: \"power4.inOut\",\n      // イージング関数を調整\n      scrollTrigger: {\n        trigger: element,\n        start: \"top 90%\",\n        // 画面の上から90%の位置でアニメーションを開始\n        toggleActions: \"play none none none\"\n      }\n    });\n  });\n}\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  var transitionLinks = document.querySelectorAll(\".transition-link\");\n  transitionLinks.forEach(function (link) {\n    link.addEventListener(\"click\", function (e) {\n      e.preventDefault(); // リンクのデフォルト動作を停止\n\n      var href = this.getAttribute(\"href\"); // リンク先のURLを取得\n\n      // ここでアニメーションを実行...\n      gsap.to(\"#content\", {\n        opacity: 0,\n        duration: 0.5,\n        onComplete: function () {\n          window.location.href = href; // アニメーション完了後にリンク先に遷移\n        }\n      });\n    });\n  });\n});\n\n//# sourceURL=webpack://wowp/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;